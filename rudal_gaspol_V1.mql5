//+------------------------------------------------------------------+
//|         GrowthAggressive_XAU_M1M5.mq5                           |
//|         Momentum Continuation Engine â€“ Gold Only                |
//+------------------------------------------------------------------+
#property strict
#include <Trade/Trade.mqh>

input double RiskPercent        = 1.5;
input int    MagicNumber        = 777888;
input int    MaxTradesPerDay    = 5;
input double MaxDrawdownPercent = 12.0;

input int EMAFast = 9;
input int EMASlow = 21;
input int EMAMid  = 50;
input int EMATrend= 200;

input int ADXPeriod = 14;
input double ADXMin = 18;

input int ATRPeriod = 14;
input double SL_ATR_Mult = 1.2;
input double TP_ATR_Mult = 2.5;

input bool UseTrailing = true;
input double Trail_ATR_Mult = 1.0;

CTrade trade;

int hEmaFast, hEmaSlow, hEmaMid, hEmaTrend;
int hADX, hATR, hMACD;

datetime lastTradeTime = 0;
int tradesToday = 0;
double peakEquity = 0;

//+------------------------------------------------------------------+
int OnInit()
{
   trade.SetExpertMagicNumber(MagicNumber);

   hEmaFast  = iMA(_Symbol,_Period,EMAFast,0,MODE_EMA,PRICE_CLOSE);
   hEmaSlow  = iMA(_Symbol,_Period,EMASlow,0,MODE_EMA,PRICE_CLOSE);
   hEmaMid   = iMA(_Symbol,_Period,EMAMid,0,MODE_EMA,PRICE_CLOSE);
   hEmaTrend = iMA(_Symbol,_Period,EMATrend,0,MODE_EMA,PRICE_CLOSE);

   hADX = iADX(_Symbol,_Period,ADXPeriod);
   hATR = iATR(_Symbol,_Period,ATRPeriod);
   hMACD= iMACD(_Symbol,_Period,12,26,9,PRICE_CLOSE);

   peakEquity = AccountInfoDouble(ACCOUNT_EQUITY);

   return(INIT_SUCCEEDED);
}
//+------------------------------------------------------------------+
double LotSize(double sl_points)
{
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double risk   = equity * RiskPercent/100.0;

   double tickValue = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
   double point     = SymbolInfoDouble(_Symbol,SYMBOL_POINT);

   double lot = risk / (sl_points * point * tickValue);

   double minLot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);
   double step   = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);

   lot = MathFloor(lot/step)*step;
   lot = MathMax(minLot,MathMin(maxLot,lot));

   return lot;
}
//+------------------------------------------------------------------+
bool RiskControl()
{
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);

   if(equity > peakEquity)
      peakEquity = equity;

   double dd = (peakEquity-equity)/peakEquity*100.0;
   if(dd >= MaxDrawdownPercent)
      return false;

   return true;
}
//+------------------------------------------------------------------+
void ManageTrailing()
{
   if(!UseTrailing) return;

   double atr[];
   ArraySetAsSeries(atr,true);
   if(CopyBuffer(hATR,0,0,1,atr)<1) return;

   double trail = atr[0]*Trail_ATR_Mult;

   for(int i=PositionsTotal()-1;i>=0;i--)
   {
      if(!PositionSelectByIndex(i)) continue;
      if(PositionGetInteger(POSITION_MAGIC)!=MagicNumber) continue;

      ulong ticket = PositionGetInteger(POSITION_TICKET);
      double open  = PositionGetDouble(POSITION_PRICE_OPEN);
      double sl    = PositionGetDouble(POSITION_SL);

      if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)
      {
         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
         double newSL = bid - trail;
         if(newSL > sl)
            trade.PositionModify(ticket,newSL,PositionGetDouble(POSITION_TP));
      }
      else
      {
         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
         double newSL = ask + trail;
         if(newSL < sl || sl==0)
            trade.PositionModify(ticket,newSL,PositionGetDouble(POSITION_TP));
      }
   }
}
//+------------------------------------------------------------------+
void CheckEntry()
{
   if(tradesToday >= MaxTradesPerDay) return;
   if(TimeCurrent()-lastTradeTime < 60) return;
   if(!RiskControl()) return;

   double emaFast[2],emaSlow[2],emaMid[1],emaTrend[1];
   double adx[1],atr[1],macd[2];

   ArraySetAsSeries(emaFast,true);
   ArraySetAsSeries(emaSlow,true);

   if(CopyBuffer(hEmaFast,0,0,2,emaFast)<2) return;
   if(CopyBuffer(hEmaSlow,0,0,2,emaSlow)<2) return;
   if(CopyBuffer(hEmaMid,0,0,1,emaMid)<1) return;
   if(CopyBuffer(hEmaTrend,0,0,1,emaTrend)<1) return;
   if(CopyBuffer(hADX,0,0,1,adx)<1) return;
   if(CopyBuffer(hATR,0,0,1,atr)<1) return;
   if(CopyBuffer(hMACD,0,0,2,macd)<2) return;

   double point = SymbolInfoDouble(_Symbol,SYMBOL_POINT);

   double sl_points = (atr[0]*SL_ATR_Mult)/point;
   double tp_points = (atr[0]*TP_ATR_Mult)/point;

   // BUY CONDITION
   if(emaFast[1]<emaSlow[1] && emaFast[0]>emaSlow[0] &&
      emaMid[0]>emaTrend[0] &&
      adx[0]>ADXMin &&
      macd[0]>0)
   {
      double lot = LotSize(sl_points);
      double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);

      trade.Buy(lot,_Symbol,ask,
                ask-sl_points*point,
                ask+tp_points*point,
                "Growth Buy");

      tradesToday++;
      lastTradeTime=TimeCurrent();
   }

   // SELL CONDITION
   if(emaFast[1]>emaSlow[1] && emaFast[0]<emaSlow[0] &&
      emaMid[0]<emaTrend[0] &&
      adx[0]>ADXMin &&
      macd[0]<0)
   {
      double lot = LotSize(sl_points);
      double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);

      trade.Sell(lot,_Symbol,bid,
                 bid+sl_points*point,
                 bid-tp_points*point,
                 "Growth Sell");

      tradesToday++;
      lastTradeTime=TimeCurrent();
   }
}
//+------------------------------------------------------------------+
void OnTick()
{
   ManageTrailing();
   CheckEntry();
}
//+------------------------------------------------------------------+
